#!/usr/bin/env python3
# -*- coding=utf-8 -*-

"""
Manage VASP job operation and extract interesting data.

This script does not run the calculation. You have to check the input files
before !!

SYNTAX
        v <sub-command> [OPTIONS]

SUB-COMMANDS

    get help
    --------

        -h, --hep, h, help
            print this help and exit.

    Manage calculations
    -------------------

        clean
            delete vasp output files in the current directory.

        restart [dirname]
            copy necessary files for a restart calculation into a restart
            directory named [dirname]. None of the copied files are modified.
            By default, the dirname is 'restart'.

        lr
            copy and save necessary files for restarting the calculation in the
            current directory. OSZICAR, OUTCAR, POSCAR and vasprun.xml files
            are saved.

        sp
            copy the necessary files for an energy calculation into a
            SinglePoint directory. In the new INCAR file, the following
            keywords are changed:
                * NSW    -> NSW = 0
                * ISMEAR -> ISMEAR = -5
                * EDIFFG -> deleted
                * IBRION -> deleted
                * ISIF   -> deleted
                * LREAL  -> deleted
                * SIGMA  -> deleted

        spb
            Do the same things as sp but add keywords for a Bader calculation:
                * LAECHG = True
                * NGXF   = XXX
                * NGYF   = YYY
                * NGZF   = ZZZ

            The values of XXX, YYY and ZZZ are computed from lattice parameters
            assuming a distance between grid points of 0.03A.

        purge
            *WARNING*, delete CHG, CHGCAR, WAVECAR, AECCAR* files in current
            directory and all subdirectories. Ask for authorization before
            deletion.

        makekpts
            Set up a KPOINTS file for bands structure calculations following
            Setyawan, W.; Curtarolo, S. Computational Materials Science 2010,
            49 (2), 299–312.

    Extract data
    ------------

        cell [FILENAME]
            print lattice parameters calculated from [FILENAME]. [FILENAME]
            must be a POSCAR/CONTCAR file. If [FILENAME] is absent, a list of
            available POSCAR/CONTCAR files in the working directory is printed.

        cl [OPTIONS]
            Read core state eigenenergies from OUTCAR file (need pymatgen).

            v cl
                Read the INCAR file and output core state eigenergy of the AO
                of the atom define by CLNT, CLN and CLL keywords.

            v cl select
                Output all available core state eigenergies and ask for the
                atom index and the AO name of the core state.

            c cl [atom index] [atomic orbital]
                Output the core state eigenergies of the atom and the atomic
                orbital defined in the options. The first atom index is 1.
                [atomic orbital] is something like 1s, 2p, 3s ...

        tdos ['FILENAME', tofile]
            read DOS from 'vasprun.xml' or from 'FILENAME' and plot it using
            matplotlib (need pymatgen). 'FILENAME' must be a valid vasprun.xml
            file.
            If tofile is present, the total DOS is printed into a file named
            'total_DOS.dat'.

        pdos ['FILENAME', tofile]
            read projected DOS from 'vasprun.xml' or from 'FILENAME' and plot
            it using matplotlib (need pymatgen). 'FILENAME' must be a valid
            vasprun.xml file.
            If tofile is present, for each element, projected DOS are printed
            into a file named 'DOS_X.dat' where X is the symbol of the
            element.

        atdos iat ['FILENAME']
            read projected DOS from 'vasprun.xml' or from 'FILENAME', extract
            projected DOS on atom index iat and dump the data into a file.
            iat goes from 1 to the number of atom.

        bands BANDPATH [DOSPATH]
            read band structure from 'vasprun.xml' and plot it using the
            BSPlotter tools included into pymatgen. BANDPATH and DOSPATH
            are the paths to the vasprun.xml file of the band structure
            calculation and the DOS calculation respectively. If DOSPATH is not
            present, the fermi level is taken from the band structure
            calculation (less accurate).

            Examples:
                v bands ./Bands ./DOS
                v bands ./

        mag [full, threshold]
            read OUTCAR and POSCAR file and print magnetization of each atom at
            the last ionic step.
            If 'full' is present, magnetization are plotted and printed into a
            file for all ionic step but only for atoms whit a magnetic moment
            higher than the treshold.o

            Examples:
                v mag
                v full
                v full .2

        charges [FILENAME]
            After a bader calculation
            `http://http://theory.cm.utexas.edu/henkelman/code/bader/`_
            Read atomic populations into ACF.dat file and compute atomic
            charges using data in POTCAR file and atom names in POSCAR file.
            If [FILENAME] is given, charges are printed into a file of name
            [FILENAME].

        cvg [STEP]
        cvg [OUTCAR] [OSZICAR] [POSCAR]
            Look at convergence of the calculation. Without any arguments, OUTCAR
            OSZICAR and POSCAR files are read. If [STEP] is present as un integer,
            considering the 'local restart' option, OUTCAR_step, OSZICAR_step and
            CONTCAR_step.vasp are read. Else, you can provide the name of OUTCAR,
            OSZICAR and POSCAR file in that order.

        forces ['FILENAME']
            Read forces acting on eahc ion in file 'FILENAME' and print them.
            Default is file 'OUTCAR', 'FILENAME' must be an OUTCAR file.

    Compute data
    ------------

        chgsum CHGCAR1 CHGCAR2 factor
            Compute CHGCAR1 + factor * CHGCAR2 where CHGCAR are denisty file.
            This command needs pymatgen.

        dep [FILE1, FILE2]
            Compute displacements of all atoms in two structures. By default,
            the vasprun.xml file is read and initial and final structures are
            compared. Two POSCAR/CONTCAR file can be also given in arguements.

        supercell NX NY NZ
            Build a supercell with the dimension NX*a x NY*b x NZ*c and ouput
            it in a POSCAR file.

            Example:
                v supercell 2 3 1

        neighbors iat radius [FILE]
            Print the neighbor list of atom [iat] in a sphere of radius
            [radius]. The structure is read on [FILE] (defautl value is
            'POSCAR'). The radius is in angstrom.

            Example:
                v neighbors 2 3.5

        allneighbors radius [FILE]
            Print all neighbors of all atoms in a sphere of radius [radius].
            The structure is read on [FILE]. The radius is in angstrom.

REMARK
        Job files are supposed to begin by 'j' or to have  a '.job' extension.

        Some functions may need pymatgen module (see http://www.pymatgen.org).

"""

from __future__ import division, print_function

import sys
import os
import shutil
import fnmatch
import numpy as np
import re
from math import sqrt, acos, pi, fabs, ceil

try:
    import matplotlib.pyplot as plt
except ImportError:
    print("\033[93m\n ## Matplotlib may be not available ##\n\033[0m")

try:
    import pymatgen as mg
    from pymatgen.io.vasp.inputs import Incar, Potcar, Poscar, Kpoints
    from pymatgen.io.vasp.outputs import Outcar, Vasprun, Oszicar, Chgcar
    from pymatgen.electronic_structure.core import Spin, OrbitalType
    from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
    from pymatgen.symmetry.bandstructure import HighSymmKpath
    from pymatgen.electronic_structure.plotter import BSPlotter, plot_brillouin_zone_from_kpath
except ImportError:
    print("\033[93m\n ## Pymatgen may be not available ##\n\033[0m")

__author__ = "Germain Salvato-Vallverdu"
__email__ = "germain.vallverdu@univ-pau.fr"
__licence__ = "GPL"
__date__ = "June 2014"

dashedLine = "".join(50 * ["-"])
float_patt = re.compile("([+-]?\d+\.\d+)")

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# General functions
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


def _die(m="", code=0):
    """ print error and exit """
    Colors.cprint("r", m)
    exit(code)


def question(message):
    """ ask a question and read answer """
    answer = None
    while answer is None:
        a = input(message + " (y/n) : ")
        if a.lower()[0] == "n":
            answer = False
        elif a.lower()[0] == "y" or a.lower()[0] == "o":
            answer = True
        else:
            print("hit 'y' for yes or 'n' for no")
    return answer

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# Check and select functions
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


def check():
    """ check options """

    options = ["h", "help", "-h", "--help",
               "clean", "sp", "spb", "restart", "purge", "lr", "makekpts",
               "cell", "cl", "chgsum", "charges", "cvg",
               "tdos", "pdos", "mag", "dep", "atdos", "bands",
               "forces", "supercell", "neighbors", "allneighbors"]

    if len(sys.argv) < 2:
        print("available sub-command:")
        line = "\t"
        for i, opt in enumerate(options):
            line += opt.rjust(14) + ","
            if (i + 1) % 6 == 0:
                print(line)
                line = "\t"

        print("try 'v help | less' to get help.")
        _die("\nERROR, you must give a sub-command", 1)

    opt = sys.argv[1]
    if opt not in options:
        _die("\nERROR, option '%s' unknown" % opt, 1)


def select():
    """ select the operation to do """

    wd = os.getcwd()

    # help
    for opt in sys.argv:
        if opt in ["h", "help", "-h", "--help"]:
            _die(__doc__)

    # command name
    opt = sys.argv[1].lower()

    if opt == "clean":
        cleanVasp()
    elif opt == "sp":
        makeSP()
    elif opt == "spb":
        interac = True
        if len(sys.argv) >= 3:
            if "-no-i" in sys.argv[2:]:
                interac = False
        makeSPBader(interac=interac)
    elif opt == "restart":
        if len(sys.argv) == 3:
            dirname = sys.argv[2]
        else:
            dirname = "restart"
        makeRestart(dirname)
    elif opt == "lr":
        makeLocalRestart()
    elif opt == "purge":
        purgeRuns()
    elif opt == "makekpts":
        fstruct = "POSCAR"
        if len(sys.argv) == 3:
            fstruct = sys.argv[2]
        if not os.path.exists(fstruct):
            _die("File %s does not exist" % fstruct, 1)
        else:
            make_kpoints(fstruct)

    elif opt == "cell":
        # POSCAR file
        narg = len(sys.argv)
        if narg == 2:
            print(wd + ":")
            posfile = fnmatch.filter(os.listdir(wd), "POSCAR*")
            posfile += fnmatch.filter(os.listdir(wd), "CONTCAR*")
            posfile += fnmatch.filter(os.listdir(wd), "*.vasp")
            for i, f in enumerate(posfile):
                print("    %3d -> %s" % (i, f))
            poscar = posfile[int(input("\nfile number = "))]

        elif narg == 3:
            poscar = sys.argv[2]

        else:
            _die("Error, bad arguments.", 1)

        cell(poscar)

    elif opt == "cl":
        coreLevel()

    elif opt == "tdos":
        tofile = False
        xmlfile = "vasprun.xml"

        if len(sys.argv) == 3:
            if sys.argv[2] == "tofile":
                tofile = True
            else:
                xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            if sys.argv[2] == "tofile":
                xmlfile = sys.argv[3]
                tofile = True
            elif sys.argv[3] == "tofile":
                xmlfile = sys.argv[2]
                tofile = True
            else:
                _die("Error, bad arguments", 1)
        elif len(sys.argv) > 4:
            _die("Error, you gave too much arguments", 1)

        plot_total_dos(xmlfile, tofile)

    elif opt == "pdos":
        tofile = False
        xmlfile = "vasprun.xml"

        if len(sys.argv) == 3:
            if sys.argv[2] == "tofile":
                tofile = True
            else:
                xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            if sys.argv[2] == "tofile":
                xmlfile = sys.argv[3]
                tofile = True
            elif sys.argv[3] == "tofile":
                xmlfile = sys.argv[2]
                tofile = True
            else:
                _die("Error, bad arguments", 1)
        elif len(sys.argv) > 4:
            _die("Error, you gave too much arguments", 1)

        plot_proj_dos(xmlfile, tofile)

    elif opt == "atdos":
        xmlfile = "vasprun.xml"

        if len(sys.argv) == 3:
            iat = sys.argv[2]
        elif len(sys.argv) == 4:
            iat = sys.argv[2]
            xmlfile = sys.argv[3]
        else:
            _die("Error, bad arguments", 1)

        try:
            iat = int(iat)
        except ValueError:
            _die("iat must be an integer", 1)

        if iat < 1:
            _die("Error, iat goes from 1 to number of atoms", 1)

        plot_at_dos(iat, xmlfile)

    elif opt == "bands":
        bandpath = "./"
        dospath = None
        narg = len(sys.argv)
        if narg == 3:
            bandpath = sys.argv[2]
        elif narg == 4:
            bandpath = sys.argv[2]
            dospath = sys.argv[3]
        elif narg > 4:
            _die("Error, too much arguments", 1)
        plot_bands(bandpath, dospath)

    elif opt == "mag":
        full = False
        th = .2
        if len(sys.argv) > 2:
            if "full" in sys.argv[2:]:
                full = True
            try:
                th = float(sys.argv[-1])
            except ValueError:
                Colors.cprint("y", "WARNING, threshold value not found or wrong value")
                print("Set default value =>", end=" ")
                th = .2
            finally:
                print("th = ", th)

        get_mag(full, th)

    elif opt == "charges":
        if len(sys.argv) == 3:
            filename = sys.argv[2]
        else:
            filename = None
        charges(filename)

    elif opt == "cvg":
        if len(sys.argv) == 2:
            poscar = "POSCAR"
            oszicar = "OSZICAR"
            outcar = "OUTCAR"
        elif len(sys.argv) == 3:
            try:
                step = int(sys.argv[2])
            except ValueError:
                _die("step must be an integer.", 1)
            poscar = "CONTCAR_%d.vasp" % step
            oszicar = "OSZICAR_%d" % step
            outcar = "OUTCAR_%d" % step
        elif len(sys.argv) == 5:
            outcar = sys.argv[2]
            oszicar = sys.argv[3]
            poscar = sys.argv[4]
        else:
            Colors.cprint("y", "\nWARNING, bad number of arguments. I read default files.\n")

        showcvg(poscar=poscar, oszicar=oszicar, outcar=outcar)

    elif opt == "forces":
        outfile = "OUTCAR"
        if len(sys.argv) == 3:
            outfile = sys.argv[2]
            if not os.path.exists(outfile):
                _die("Error, file %s does not exist" % outfile, 1)

        get_forces(outfile)

    elif opt == "chgsum":
        chgsum()

    elif opt == "dep":
        xmlfile = "vasprun.xml"
        fs1 = fs2 = None
        if len(sys.argv) == 3:
            xmlfile = sys.argv[2]
        elif len(sys.argv) == 4:
            xmlfile = None
            fs1 = sys.argv[2]
            fs2 = sys.argv[3]

        get_deplacement(xmlfile, fs1, fs2)

    elif opt == "supercell":
        if len(sys.argv) == 5:
            try:
                nx = int(sys.argv[2])
                ny = int(sys.argv[3])
                nz = int(sys.argv[4])
            except ValueError:
                _die("nx, ny, nz must be integers", 1)
        else:
            print("\nusage : v supercell 2 3 1")
            _die("Incorrect number of arguments", 1)

        make_supercell(nx, ny, nz)

    elif opt == "neighbors":
        struct = "POSCAR"
        radius = 3.

        try:
            iat = int(sys.argv[2])
        except ValueError:
            _die("iat must be an integer", 1)
        except IndexError:
            _die("Incorrect number of arguments", 1)

        try:
            radius = float(sys.argv[3])
        except ValueError:
            _die("radius must be a floating number", 1)
        except IndexError:
            _die("Incorrect number of arguments", 1)

        if len(sys.argv) == 5:
            struct = sys.argv[4]

        neighbors(iat, radius, struct)

    elif opt == "allneighbors":
        struct = "POSCAR"
        radius = 3.

        try:
            radius = float(sys.argv[2])
        except ValueError:
            _die("radius must be a floating number", 1)
        except IndexError:
            _die("Incorrect number of arguments", 1)

        if len(sys.argv) == 4:
            struct = sys.argv[3]

        all_neighbors(radius, struct)

    else:
        _die("This option is still not implemented")

    if opt in ["sp", "spb", "restart", "lr"]:
        Colors.cprint("y", "\nCAREFULLY look at the input files before running the calculation")

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# Manage calculations
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


def makeLocalRestart():
    """ save useful files for restarting a vasp calculation """

    def saveFile(f, n, ext=""):
        """ backup a file """
        fbase = os.path.splitext(f)[0]
        print("cp %11s -> %s_%d%s" % (f, fbase, n + 1, ext))
        shutil.copy(os.path.join(wd, "%s" % f),
                    os.path.join(wd, "%s_%d%s" % (fbase, n + 1, ext)))

    wd = os.getcwd()

    # save first POSCAR
    if not os.path.exists(os.path.join(wd, "POSCAR_ini.vasp")):
        print("cp POSCAR -> POSCAR_ini.vasp")
        shutil.copy(os.path.join(wd, "POSCAR"), os.path.join(wd, "POSCAR_ini.vasp"))

    # restart number
    n = len(fnmatch.filter(os.listdir(wd), "CONTCAR_*.vasp"))
    print("restart number %d" % (n + 1))

    print("\nbackup some files")
    # save CONTCAR
    saveFile("CONTCAR", n, ext=".vasp")
    # save OSZICAR
    saveFile("OSZICAR", n)
    # save OUTCAR
    saveFile("OUTCAR", n)
    # save vasprun
    saveFile("vasprun.xml", n, ext=".xml")

    # copy CONTCAR -> POSCAR
    print("\nset up the new calculation")
    print("cp CONTCAR -> POSCAR")
    shutil.copy(os.path.join(wd, "CONTCAR"), os.path.join(wd, "POSCAR"))


def makeRestart(dirname="restart"):
    """ copy necessary files for restarting a vasp calculation """

    print("# copying input files")
    wd = os.getcwd()
    ndir = os.path.join(wd, dirname)

    # create directory
    if os.path.exists(ndir):
        if not question(dirname + " directory exists, continue ?"):
            _die()
    else:
        os.mkdir(ndir)

    # copy input files
    for f in ["INCAR", "POTCAR"]:
        if os.path.exists(os.path.join(wd, f)):
            print("cp " + f + " -> " + ndir)
            shutil.copy(os.path.join(wd, f), ndir)
        else:
            _die("File {0} does not exist".format(f), 1)

    # KPOINTS
    if os.path.exists(os.path.join(wd, "KPOINTS")):
        print("cp KPOINTS -> " + ndir)
        shutil.copy(os.path.join(wd, "KPOINTS"), ndir)
    else:
        Colors.cprint("y", "I did not find a KPOINTS file ! Are you using KSPACING ?")

    # CONTCAR -> POSCAR
    if os.path.exists(os.path.join(wd, "CONTCAR")):
        print("cp CONTCAR -> " + os.path.join(ndir, "POSCAR"))
        shutil.copy(os.path.join(wd, "CONTCAR"), os.path.join(ndir, "POSCAR"))
    else:
        _die("CONTCAR file not found", 1)

    # WAVECAR, CHGCAR
    for f in ["WAVECAR", "CHGCAR"]:
        if os.path.exists(f) and os.path.getsize(f) != 0:
            print("cp " + f + " -> " + ndir)
            shutil.copy(os.path.join(wd, f), ndir)

    # job file
    jobs = fnmatch.filter(os.listdir(wd), "j*")
    jobs += fnmatch.filter(os.listdir(wd), "*.job")
    jobs = [job for job in jobs if not fnmatch.fnmatchcase(job, "*.o*")]
    if len(jobs) == 1:
        print("cp " + jobs[0] + " -> " + ndir)
        shutil.copy(os.path.join(wd, jobs[0]), ndir)
    elif len(jobs) > 1:
        if question("Do you want to select a job file ?"):
            print("\nSelect a job file among:")
            for i, job in enumerate(jobs):
                print("     %d : %s" % (i, job))
            job = jobs[int(input("job file number = "))]
            print("cp " + job + " -> " + ndir)
            shutil.copy(os.path.join(wd, job), ndir)
    else:
        Colors.cprint("y", "I did not find a job file, copy it by yourself")


def makeSP(dirname="SinglePoint"):
    """ copy necessary files for a single point energy calculation into a
    directory called SinglePoint. The new INCAR file is modified in the
    following way:
        * NSW    -> NSW = 0
        * ISMEAR -> ISMEAR = -5
        * EDIFFG -> deleted
        * IBRION -> deleted
        * ISIF   -> deleted
        * LREAL  -> deleted
        * SIGMA  -> deleted
    """

    wd = os.getcwd()
    spdir = os.path.join(wd, dirname)

    # copy files
    makeRestart(dirname)

    # read INCAR and delete or change lines
    Colors.cprint("y", "\n# setting up INCAR file")
    incar = open(os.path.join(wd, "INCAR"), "r").readlines()

    lorbit = False
    dline = list()
    for i, line in enumerate(incar):
        for tag in ["EDIFFG", "IBRION", "ISIF", "LREAL", "SIGMA"]:
            if tag in line:
                print("delete : " + line.strip())
                dline.append(line)

        if "NSW" in line:
            incar[i] = "  NSW = 0\n"

        elif "ISMEAR" in line:
            incar[i] = "  ISMEAR = -5\n"

        elif "LORBIT" in line:
            lorbit = True

    # remove selected line
    for line in dline:
        incar.remove(line)

    # add some keywords
    if not lorbit:
        incar.append("\nAdded tags\n")
        incar.append("  LORBIT = 11\n")

    # write new INCAR
    open(os.path.join(spdir, "INCAR"), "w").writelines(incar)


def makeSPBader(dirname="SinglePoint", dx=0.03, interac=True):
    """ copy necessary files for a single point energy calculation into a
    directory called SinglePoint and add specific key words necessary for a
    bader charges calculation. The new INCAR file is modified in the
    following way:
        * NSW    -> NSW = 0
        * ISMEAR -> ISMEAR = -5
        * EDIFFG -> deleted
        * IBRION -> deleted
        * ISIF   -> deleted
        * LREAL  -> deleted
        * SIGMA  -> deleted
        * LAECHG -> added LAECHG = True
    """

    wd = os.getcwd()
    spdir = os.path.join(wd, dirname)

    # set up singlePoint calculation
    makeSP(dirname)

    # read INCAR and delete or change lines
    print("\n# Adding bader keywords")
    incar = open(os.path.join(spdir, "INCAR"), "r").readlines()

    dline = list()
    present = False
    for i, line in enumerate(incar):
        for tag in ["LAECHG", "NGXF", "NGYF", "NGZF"]:
            if tag in line:
                present = True
                dline.append(line)

    # remove selected line
    if present:
        print("Some bader related keywords are presents and might be modified.")
        for line in dline:
            print(line[:-1])
        if question("\nThese lines will be deleted. Continu ?"):
            for line in dline:
                incar.remove(line)
        else:
            _die()

    # read CONTCAR file
    poscar = open(os.path.join(spdir, "POSCAR"), "r").readlines()
    scale = float(poscar[1])
    veca = [scale * float(x) for x in poscar[2].split()[0:3]]
    vecb = [scale * float(x) for x in poscar[3].split()[0:3]]
    vecc = [scale * float(x) for x in poscar[4].split()[0:3]]
    a = sqrt(veca[0]**2 + veca[1]**2 + veca[2]**2)
    b = sqrt(vecb[0]**2 + vecb[1]**2 + vecb[2]**2)
    c = sqrt(vecc[0]**2 + vecc[1]**2 + vecc[2]**2)

    # bader grid
    if interac and not question("dx = %f \t accept ?" % dx):
        print("Enter a new dx value")
        dx = float(input("dx = "))
        print("dx = %f" % dx)
    ngxf = int(ceil(a / dx / 10.) * 10)
    ngyf = int(ceil(b / dx / 10.) * 10)
    ngzf = int(ceil(c / dx / 10.) * 10)

    print("Bader grid :")
    print("dx = {0} ".format(dx))
    print("a = %8.3f      NGXF = %d" % (a, ngxf))
    print("b = %8.3f      NGYF = %d" % (b, ngyf))
    print("c = %8.3f      NGZF = %d" % (c, ngzf))

    # add bader keywords
    incar.append("\nBader\n")
    incar.append("  LAECHG = True\n")
    incar.append("  NGXF = %d\n" % ngxf)
    incar.append("  NGYF = %d\n" % ngyf)
    incar.append("  NGZF = %d\n" % ngzf)

    # write new INCAR
    with open(os.path.join(spdir, "INCAR"), "w") as f:
        f.writelines(incar)


def cleanVasp():
    """ delete vasp output files """
    wd = os.getcwd()
    files = ["IBZKPT", "OSZICAR", "XDATCAR", "PCDAT", "DOSCAR", "CONTCAR",
             "CHG", "CHGCAR", "WAVECAR", "PROCAR", "EIGENVAL", "vasprun.xml",
             "OUTCAR", "DYNMAT"]
    for f in files:
        if os.path.exists(os.path.join(wd, f)):
            print("rm " + os.path.join(wd, f))
            os.remove(os.path.join(wd, f))


def purgeRuns():
    """
    delete WAVECAR, CHGCAR, CHG, AECCAR* in current directory and all
    subdirectories
    """

    filenames = ["WAVECAR", "CHG", "CHGCAR*", "AECCAR*"]

    taille = 0
    delfile = list()
    for root, dirs, files in os.walk(os.getcwd()):
        for name in files:
            if not os.path.isfile(os.path.join(root, name)):
                continue
            for filename in filenames:
                if fnmatch.fnmatch(name, filename):
                    fname = os.path.join(root, name)
                    if input("delete %s ? (y/n) : " % fname) == "y":
                        print("---> remove %s" % fname)
                        taille += os.path.getsize(fname)
                        os.remove(fname)
                        delfile.append(fname)

    print(dashedLine)
    print(" Total size of deleted files : " + HumanSize.compute(taille))
    print(dashedLine)
    print(" Deleted files are :")
    for f in delfile:
        print(f)
    print(dashedLine)


def make_kpoints(fstruct="POSCAR", ndiv=20):
    """
    Create a KPOINTS file for a band structure calculation. This script use
    methods of pymatgen in order to compute and select high symetry lines
    in the first brillouin zone.

    Setyawan, W.; Curtarolo, S. Computational Materials Science 2010,
    49 (2), 299–312.
    """
    # read structure
    struct = mg.Structure.from_file(fstruct)

    # symmetry information
    struct_sym = SpacegroupAnalyzer(struct)
    print("\nLattice details:")
    print("----------------")
    print("lattice type : {0}".format(struct_sym.get_lattice_type()))
    print("space group  : {0} ({1})".format(struct_sym.get_space_group_symbol(),
                                            struct_sym.get_space_group_number()))

    # Compute first brillouin zone
    ibz = HighSymmKpath(struct)
    print("ibz type     : {0}".format(ibz.name))
    plot_brillouin_zone_from_kpath(ibz, savefig="path.png")

    # print specific kpoints in the first brillouin zone
    print("\nList of high symmetry k-points:")
    print("-------------------------------")
    for key, val in ibz.kpath["kpoints"].items():
        print("%8s %s" % (key, str(val)))

    # suggested path for the band structure
    print("\nSuggested paths in first brillouin zone:")
    print("----------------------------------------")
    for i, path in enumerate(ibz.kpath["path"]):
        print("   %2d:" % (i + 1), " -> ".join(path))

    # write the KPOINTS file
    print("\nCorresponding KPOINTS file")
    print("--------------------------")
    print(Kpoints.automatic_linemode(ndiv, ibz))

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# extract data
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


def cell(poscar="CONTCAR"):
    """
    Compute and print lattice parameters

    Args:
        poscar(string): file name
    """

    # check data
    if not os.path.exists(poscar):
        _die("Error : file {0} does not exist".format(poscar), 1)

    # read poscar file
    lines = open(poscar, "r").readlines()
    title = lines[0][0:-1]
    scale = float(lines[1])
    veca = [scale * float(v) for v in lines[2].split()[0:3]]
    vecb = [scale * float(v) for v in lines[3].split()[0:3]]
    vecc = [scale * float(v) for v in lines[4].split()[0:3]]

    # lattice parameters
    a = sqrt(veca[0]**2 + veca[1]**2 + veca[2]**2)
    b = sqrt(vecb[0]**2 + vecb[1]**2 + vecb[2]**2)
    c = sqrt(vecc[0]**2 + vecc[1]**2 + vecc[2]**2)

    # angles
    scalab = veca[0] * vecb[0] + veca[1] * vecb[1] + veca[2] * vecb[2]
    scalac = veca[0] * vecc[0] + veca[1] * vecc[1] + veca[2] * vecc[2]
    scalbc = vecb[0] * vecc[0] + vecb[1] * vecc[1] + vecb[2] * vecc[2]

    scalab /= a * b
    scalac /= a * c
    scalbc /= b * c

    # alpha
    if fabs(scalbc) < 1.:
        alpha = acos(scalbc) * 180. / pi
    else:
        _die("Error, angle alpha")

    if fabs(scalac) < 1.:
        beta = acos(scalac) * 180. / pi
    else:
        _die("Error, angle beta")

    if fabs(scalab) < 1.:
        gamma = acos(scalab) * 180. / pi
    else:
        _die("Error, angle gamma")

    print(dashedLine)
    print(poscar + " : " + title)
    print(dashedLine)
    print("a     = %10.5f" % a)
    print("b     = %10.5f" % b)
    print("c     = %10.5f" % c)
    print("alpha = %10.3f" % alpha)
    print("beta  = %10.3f" % beta)
    print("gamma = %10.3f" % gamma)
    print(dashedLine)


def coreLevel():
    """ extract core level """

    AOname = ["s", "p", "d", "f"]

    cl = Outcar("OUTCAR").read_core_state_eigen()
    symbol = [specie.symbol for specie in mg.Structure.from_file("POSCAR").species]

    if len(sys.argv) == 2:
        # try to read from INCAR
        incar = Incar.from_file("INCAR")
        iat = incar["CLNT"]

        n = incar["CLN"]
        l = incar["CLL"]

        ao = "%d%s" % (n, AOname[l])

    elif sys.argv[2] == "select":
        # ask for atom number and orbital
        print("    atom    Atomic orbital")
        for iat, cl_at in enumerate(cl):
            line = "%4s %4d    " % (symbol[iat], iat + 1)
            line += "   ".join(cl_at.keys())
            print(line)

        iat = int(input("Atom number : "))
        ao = input("atomic orbital : ")

    else:
        # atom and AO selected from command line
        try:
            iat = int(sys.argv[2])
        except ValueError:
            _die("Error atom number must be an integer", 1)

        if iat <= 0:
            raise ValueError("Error, atom number must be between 1 and number of atom")

        ao = sys.argv[3]

    # print core state energy
    if ao in cl[iat - 1]:
        print("atom %d -> %2s_%2s = %f eV" % (iat, symbol[iat - 1], ao,
                                              cl[iat - 1][ao][-1]))
    else:
        _die("Atom index and AO unconsistent.\
            \n    atom: %s %d\n    AO  : %s" % (symbol[iat - 1], iat, ao), 1)


def plot_total_dos(xmlfile="vasprun.xml", tofile=False):
    """ Plot total DOS using matplotlib """

    # check xml file
    if not os.path.exists(xmlfile):
        _die("File %s does not exist" % xmlfile, 1)

    # read
    run = Vasprun(xmlfile, parse_eigen=False)
    print("gap = %12.6f" % run.complete_dos.get_gap())

    if tofile:
        if not run.is_spin:
            lines = "#  E - Ef       total\n"
            for e, tdos in zip(run.tdos.energies, run.tdos.densities[Spin.up]):
                lines += "%12.7f %12.7f\n" % (e - run.efermi, tdos)
        else:
            lines = "#  E - Ef        Spin up      Spin down\n"
            for e, up, down in zip(run.tdos.energies,
                                   run.tdos.densities[Spin.up],
                                   run.tdos.densities[Spin.down]):
                lines += "%12.7f %12.7f %12.7f\n" % (e - run.efermi, up, -down)

        with open("total_DOS.dat", "w") as f:
            f.write(lines)

    else:
        # plot
        font = {'family': 'serif', 'size': 20}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27))  # A4

        plt.plot(run.tdos.energies - run.efermi, run.tdos.densities[Spin.up],
                 "r-", label="Spin up")
        if run.is_spin:
            plt.plot(run.tdos.energies - run.efermi, -run.tdos.densities[Spin.down],
                     "b-", label="Spin down")

        # set up figure
        plt.title("Density of states of " +
                  run.initial_structure.composition.reduced_formula)
        plt.xlabel(r"$E - E_{f}$   /   eV")
        plt.ylabel("Density of states")
        plt.grid(True)
        ymin, ymax = plt.ylim()
        plt.vlines(0, ymin, ymax, color="k", lw=1, linestyle="--")
        if run.is_spin:
            xmin, xmax = plt.xlim()
            plt.hlines(0, xmin, xmax, color="k", lw=1)
            plt.legend(prop={"size": 18})
        else:
            ymin, ymax = plt.ylim()
            plt.ylim(0, ymax)

        plt.show()


def plot_proj_dos(xmlfile="vasprun.xml", tofile=False):
    """ Plot projected DOS using matplotlib """

    # check xml file
    if not os.path.exists(xmlfile):
        _die("File %s does not exist" % xmlfile, 1)

    # read
    run = Vasprun(xmlfile, parse_eigen=False)
    dos = run.complete_dos
    print("gap = %12.6f" % dos.get_gap())

    oatypes = (OrbitalType.s, OrbitalType.p, OrbitalType.d)

    if tofile:
        el_tdos = dos.get_element_dos()
        for el, tdos in el_tdos.items():
            el_dos = dos.get_element_spd_dos(el)
            lines = "# Element : %s\n" % el.symbol
            lines += "# column  1: E - E_fermi (eV)\n"
            if not run.is_spin:
                lines += "# column  2: DOS projected on %s\n" % el.symbol
                for i, oa in enumerate(oatypes):
                    lines += "# column %2d: DOS projected on AO type %s\n" % (i + 3, oa.name)
                for i in range(len(dos.energies)):
                    lines += "%12.7f " % (dos.energies[i] - dos.efermi)
                    lines += "%12.7f " % tdos.densities[Spin.up][i]
                    for oa in oatypes:
                        lines += "%12.7f " % el_dos[oa].densities[Spin.up][i]
                    lines += "\n"

            else:
                lines += "# column  2: DOS up projected on %s\n" % el.symbol
                lines += "# column  3: DOS down projected on %s\n" % el.symbol
                i = 4
                for oa in oatypes:
                    lines += "# column %2d: DOS up projected on AO type %s\n" % (i, oa.name)
                    i += 1
                    lines += "# column %2d: DOS down projected on AO type %s\n" % (i, oa.name)
                    i += 1
                for i in range(len(dos.energies)):
                    lines += "%12.7f " % (dos.energies[i] - dos.efermi)
                    lines += "%12.7f " % tdos.densities[Spin.up][i]
                    lines += "%12.7f " % -tdos.densities[Spin.down][i]
                    for oa in oatypes:
                        lines += "%12.7f " % el_dos[oa].densities[Spin.up][i]
                        lines += "%12.7f " % -el_dos[oa].densities[Spin.down][i]
                    lines += "\n"

            with open("DOS_%s.dat" % el.symbol, "w") as f:
                f.write(lines)

    else:
        # plot
        font = {'family': 'serif', 'size': 20}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27))  # A4

        colors = {OrbitalType.s: "r-", OrbitalType.p: "g-", OrbitalType.d: "b-"}
        nplots = len(dos.structure.composition.elements)
        for i, el in enumerate(dos.structure.composition.elements):
            el_dos = dos.get_element_spd_dos(el)
            plt.subplot(nplots, 1, i + 1)
            plt.plot(dos.energies - dos.efermi, dos.densities[Spin.up],
                     linestyle="-", color="#888888",
                     label="total")
            plt.fill_between(dos.energies - dos.efermi, np.zeros(len(dos.energies)),
                             dos.densities[Spin.up], color="#CCCCCC")
            for orb, pdos in el_dos.items():
                plt.plot(dos.energies - dos.efermi, pdos.densities[Spin.up], colors[orb],
                         label=orb)

            if run.is_spin:
                plt.plot(dos.energies - dos.efermi, -dos.densities[Spin.down],
                         linestyle="-", color="#888888")
                plt.fill_between(dos.energies - dos.efermi, np.zeros(len(dos.energies)),
                                 -dos.densities[Spin.down], color="#CCCCCC")
                for orb, pdos in el_dos.items():
                    plt.plot(dos.energies - dos.efermi, -pdos.densities[Spin.down],
                             colors[orb])
                xmin, xmax = plt.xlim()
                plt.hlines(0, xmin, xmax, color="k")

            ymin, ymax = plt.ylim()
            plt.vlines(0, ymin, ymax, color="k", linestyle="-")
            plt.ylim(ymin, ymax)
            plt.ylabel("Element : " + el.symbol)
            plt.grid(True)
            plt.legend(prop={"size": "18"})

        # plt.subplots_adjust(hspace=0.)
        plt.suptitle("Projected DOS of elements of " +
                     run.initial_structure.composition.reduced_formula)
        plt.xlabel(r"$E - E_{f}$   /   eV")

        plt.show()


def plot_at_dos(iat, xmlfile="vasprun.xml"):
    """ Print DOS projected on atom iat

        args:
            iat (int): index of the atom from 1 to # of atom

    """

    # check xml file
    if not os.path.exists(xmlfile):
        _die("File %s does not exist" % xmlfile, 1)

    # read
    run = Vasprun(xmlfile, parse_eigen=False)
    dos = run.complete_dos
    site = run.initial_structure[iat - 1]
    spd_dos = dos.get_site_spd_dos(site)
    sitedos = dos.get_site_dos(site)
    print("gap = %12.6f" % dos.get_gap())

    oatypes = (OrbitalType.s, OrbitalType.p, OrbitalType.d)

    # print file
    lines = "# Element  : %s_%d\n" % (site.specie.symbol, iat)
    lines += "# column  1: E - E_fermi (eV)\n"
    nc = 1
    if not run.is_spin:
        # header
        nc += 1
        lines += "# column %2d: DOS projected on %s_%d\n" % (nc,
                                                             site.specie.symbol, iat)
        for oa in oatypes:
            nc += 1
            lines += "# column %2d: DOS projected on all %s AO\n" % (nc, oa)
        for orb in dos.pdos[site]:
            nc += 1
            lines += "# column %2d: DOS projected on %s\n" % (nc, orb)

        # data
        for i in range(len(dos.energies)):
            lines += "%12.7f " % (dos.energies[i] - dos.efermi)
            lines += "%12.7f " % sitedos.densities[Spin.up][i]
            for oa in oatypes:
                lines += "%12.7f" % spd_dos[oa].densities[Spin.up][i]
            for pdos in dos.pdos[site].values():
                lines += "%12.7f" % pdos[Spin.up][i]
            lines += "\n"

    else:
        # header
        nc += 1
        lines += "# column %2d: DOS up projected on %s_%d\n" % (nc,
                                                                site.specie.symbol, iat)
        nc += 1
        lines += "# column %2d: DOS down projected on %s_%d\n" % (nc,
                                                                  site.specie.symbol, iat)
        for orb in oatypes:
            nc += 1
            lines += "# column %2d: DOS up projected on all %s AO\n" % (nc, orb)
            nc += 1
            lines += "# column %2d: DOS down projected on all %s AO\n" % (nc, orb)
        for orb in dos.pdos[site]:
            nc += 1
            lines += "# column %2d: DOS up projected on %s\n" % (nc, orb)
            nc += 1
            lines += "# column %2d: DOS down projected on %s\n" % (nc, orb)

        # data
        for i in range(len(dos.energies)):
            lines += "%12.7f " % (dos.energies[i] - dos.efermi)
            lines += "%12.7f " % sitedos.densities[Spin.up][i]
            lines += "%12.7f " % sitedos.densities[Spin.down][i]
            for orb in oatypes:
                lines += "%12.7f" % spd_dos[orb].densities[Spin.up][i]
                lines += "%12.7f" % spd_dos[orb].densities[Spin.down][i]
            for pdos in dos.pdos[site].values():
                lines += "%12.7f" % pdos[Spin.up][i]
                lines += "%12.7f" % pdos[Spin.down][i]
            lines += "\n"

    with open("DOS_%s%d.dat" % (site.specie.symbol, iat), "w") as f:
        f.write(lines)


def plot_bands(bandpath, dospath=None):
    """
    Plot the band structure using the BSPlotter included in pymatgen. bandpath
    and dospath are the paths to the vasprun.xml file of the band structure
    calculation and the DOS calculation respectively. The dospath is used
    to read the fermi level. If dospath is None, the fermi level is read in
    the band structure calculation (less accurate).

    The function assumes a KPOINTS file is present in bandpath folder and the
    band structure calculation was done in line mode.

    Args:
        bandpath (str): path to the vasprun.xml file of the band structure
        dospath (str): path to the vasprun.xml file of the DOS
    """
    # read vasprun.xml from band structure calculation
    bandxml = os.path.join(bandpath, "vasprun.xml")
    if os.path.exists(bandxml):
        bandrun = Vasprun(bandxml, parse_eigen=True)
    else:
        _die("BANDPATH: File {0} does not exist".format(bandxml), 1)

    # read efermi from DOS calculation if present
    if dospath:
        dosxml = os.path.join(dospath, "vasprun.xml")
        if os.path.exists(dosxml):
            efermi = Vasprun(dosxml, parse_eigen=False).efermi
        else:
            _die("DOSPATH: File {0} does not exsit".format(dosxml), 1)
    else:
        efermi = bandrun.efermi

    # check KPOINTS file is available
    kpoint = os.path.join(bandpath, "KPOINTS")
    if not os.path.exists(kpoint):
        _die("KPOINTS file not find: {0}".format(kpoint), 1)

    # band structure plot
    bands = bandrun.get_band_structure(kpoints_filename=kpoint, efermi=efermi,
                                       line_mode=True)
    BSPlotter(bands).show()


def get_mag(full=False, plotThreshold=.1):
    """ Read OUTCAR and POSCAR file and print magnetization """

    # check files exist
    for f in ["POSCAR", "OUTCAR"]:
        if not os.path.exists(f):
            _die("File %s is needed and does not exist" % f, 1)

    # read
    outcar = Outcar("OUTCAR")
    if len(outcar.magnetization) == 0:
        _die("Magnetization not found in OUTCAR file. Check INCAR", 1)

    # print
    p = Poscar.from_file("POSCAR")
    print("\n# " + dashedLine)
    print("# magnetization for each atom")
    print("# " + dashedLine)
    print("# iat name   s       p       d       tot")
    print("# " + dashedLine)
    iat = 0
    for site, mag in zip(p.structure.sites, outcar.magnetization):
        iat += 1
        line = "%4d %4s" % (iat, site.specie.symbol)
        for val in mag.values():
            line += "%8.3f" % val
        print(line)
    print("# " + dashedLine)

    # ionic optimization case, follow magnetization
    if full:
        # read all magnetization
        with open("OUTCAR", "r") as f:
            outcar = f.readlines()

        # locate magnetization data
        positions = [i for i, line in enumerate(outcar)
                     if "magnetization (x)" in line]

        # delete the last position (duplicate)
        positions.pop(-1)
        nstep = len(positions)

        # read values
        moments = list()
        for pos in positions:
            imom = list()
            for line in outcar[pos + 4:]:
                if "----" in line:
                    break
                imom.append(float(line.split()[4]))
            moments.append(imom)
        moments = np.array(moments)

        # do not plot moments if magnetization < plotThreshold
        Natoms = len(p.structure)
        plotList = np.where(np.max(np.fabs(moments), axis=0) > plotThreshold,
                            Natoms * [True], Natoms * [False])

        # plot
        font = {'family': 'sans', 'size': 18}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27))  # A4
        ax = plt.subplot(111)
        box = ax.get_position()
        ax.set_position([box.x0, box.y0, box.width * .9, box.height])
        # plt.xlim((-.5, nstep + -.5))
        plt.grid(True)
        plt.xlabel("Ionic step")
        plt.ylabel("Magnetization")
        for iat in range(Natoms):
            if plotList[iat]:
                plt.plot(range(nstep), [m[iat] for m in moments],
                         linestyle="--", marker="o",
                         label=r"$%s_{%d}$" % (p.structure.species[iat], iat))
        plt.legend(loc="center left", bbox_to_anchor=(1, .5), fontsize="small")
        plt.show()

        # save data to file
        with open("magnetization.dat", "w") as f:
            f.write("# Magnetization data as a function of the ionic step\n")
            f.write("# column 1: ionic step\n")
            nc = 1
            for iat in range(Natoms):
                if plotList[iat]:
                    nc += 1
                    f.write("# column %d: atom %s_%d\n" % (nc, p.structure.species[iat], iat))
            for i, moment in enumerate(moments):
                line = "%4d" % i
                line += "".join(["%8.3f" % moment[iat] for iat in range(Natoms) if plotList[iat]])
                f.write(line + "\n")


def charges(filename=None):
    """
    Compute atomic charges from a Bader caclculations done with the bader
    program of the University of Texas at Austin :

    http://theory.cm.utexas.edu/bader/

    Requirements :
        * a ACF.dat file (bader output)
        * a POSCAR/CONTCAR file of the structure (read atom names).
        * a POTCAR file (read valence electron)
    """

    #
    # read atom names
    #
    if os.path.exists("POSCAR"):
        struct = mg.Structure.from_file("POSCAR")
        atomNames = [el.symbol for el in struct.species]
        compo = struct.composition.as_dict()

    elif os.path.exists("CONTCAR"):
        struct = mg.Structure.from_file("CONTCAR")
        atomNames = [el.symbol for el in struct.species]
        compo = struct.composition.as_dict()

    else:
        _die("ERROR: need a POSCAR/CONTCAR file to get atom names", 1)

    nat = len(atomNames)

    #  
    # read potcar
    #
    if os.path.exists("POTCAR"):
        potcar = Potcar.from_file("POTCAR")
    else:
        _die("ERROR: need a POTCAR file", 1)

    #
    # System composition and valence electron
    #
    lines = "Data read on POTCAR file :\n"
    valence = dict()
    nelect = 0
    for singlePotcar in potcar:
        lines += "%3s (x%d)    POTCAR : %6s     zval : %5.1f\n" % \
                 (singlePotcar.element, compo[singlePotcar.element],
                  singlePotcar.symbol, singlePotcar.zval)
        valence[singlePotcar.element] = singlePotcar.zval
        nelect += singlePotcar.zval * compo[singlePotcar.element]

    lines += "\nTotal number of valence electrons : %d\n" % nelect

    #
    # read population from ACF.dat file
    #
    pop_patt = re.compile("^\s*\d+\s*([+-]?\d+\.\d+)")
    nelec_patt = re.compile("^\s*NUMBER OF ELECTRONS:\s*(\d+.\d+)")
    if os.path.exists("ACF.dat"):
        with open("ACF.dat", "r") as acf:
            population = list()
            for line in acf:
                if pop_patt.match(line):
                    population.append(float(float_patt.findall(line)[3]))
                elif nelec_patt.match(line):
                    m = nelec_patt.match(line)
                    bader_nelec = float(m.group(1))
        if len(population) != nat:
            _die("Error, number of atom in ACF.dat not consistent", 1)
    else:
        _die("ERROR: file ACF.dat not found", 1)

    #
    # output
    #
    lines += "\n   i  name   Z      pop       charge\n"
    lines += dashedLine + "\n"
    for iat in range(nat):
        charge = valence[atomNames[iat]] - population[iat]
        lines += "%4d %4s %4d %10.4f %10.4f\n" % (iat + 1, atomNames[iat],
                                                  valence[atomNames[iat]], population[iat], charge)
    lines += dashedLine + "\n"

    #
    # average charges
    #
    avePop = dict()
    av2Charge = dict()
    for el in struct.composition.elements:
        avePop[el.symbol] = 0.
        av2Charge[el.symbol] = 0.

    lines += "Composition : {0}\n".format(struct.composition.reduced_formula)

    nelec = 0
    for iat in range(nat):
        name = atomNames[iat]
        avePop[name] += population[iat]
        av2Charge[name] += (valence[name] - population[iat])**2
        nelec += valence[name]

    lines += "Averages :\n"
    lines += " name   Z          charge\n"
    lines += dashedLine + "\n"
    for el in struct.composition.elements:
        nel = struct.composition[el.symbol]
        name = el.symbol
        avePop[name] /= nel
        charge = valence[name] - avePop[name]

        av2Charge[name] /= nel
        if fabs(av2Charge[name] - charge**2) < 1e-5:
            av2Charge[name] = 0.
        else:
            av2Charge[name] = sqrt(av2Charge[name] - charge**2)

        lines += "%4s %4d %10.4f +/- %7.4f\n" % (name, valence[name], charge,
                                                 av2Charge[name])
    lines += dashedLine + "\n"

    if not filename:
        print(lines)
    else:
        with open(filename, "w") as fout:
            fout.write(lines)

    # check total number of electrons
    if np.fabs(nelec - bader_nelec) < 0.01:
        color = "g"
    elif np.fabs(nelec - bader_nelec) < 0.1:
        color = "y"
        Colors.cprint(color, "WARNING ! error on elecrons number > 0.01")
        Colors.cprint(color, "Check the number of electrons\n")
    else:
        color = "r"
        Colors.cprint(color, "WARNING ! error on elecrons number > 0.1")
        Colors.cprint(color, "WARNING ! YOU MUST CHECK THE NUMBER OF ELECTRONS\n")

    Colors.cprint(color, "Number of valence electrons          = %10.4f" % nelec)
    Colors.cprint(color, "Number of computed valence electrons = %10.4f" % bader_nelec)


def readSelectiveDynamics(f="POSCAR"):
    """
    Read slective dynamics info on a POSCAR file and return a boolean and the
    constraints.
        * freeze is True if there is one 'F' for the considered atom
        * freeze is False if the three flags are 'T' for the considered atom'

    Returns:
        freeze (list): list of [bool, "F/T", "F/T", "F/T"]
    """

    if os.path.exists(f):
        with open(f, "r") as poscarfile:
            poscar = poscarfile.readlines()
            try:
                # vasp 5
                nat = sum([int(val) for val in poscar[6].split()])
            except ValueError:
                # vasp 4
                nat = sum([int(val) for val in poscar[5].split()])

            if poscar[7][0].lower() == "s":
                freeze = list()
                iat = 0
                for iat in range(nat):
                    line = [el.upper() for el in poscar[9 + iat].split()[3:6]]
                    if "F" in line:
                        freeze.append([True] + line)
                    else:
                        freeze.append([False] + line)
            else:
                Colors.cprint("y", "Selective Dynamics is not present in %s" % f)
                freeze = [[False, " ", " ", " "] for iat in range(nat)]

    else:
        _die("\nError, I need a POSCAR file", 1)

    return freeze


def showcvg(outcar="OUTCAR", oszicar="OSZICAR", poscar="POSCAR"):
    """
    Output graphs for looking at convergence of the calculation.
    Take care at the consistency of OUTCAR, OSZICAR and POSCAR files.
    The POSCAR file is needed to get the constraints. The OSZICAR file is
    """

    # check files
    for f in [outcar, oszicar, poscar]:
        if not os.path.exists(f):
            _die("File %s does not exist" % f, 1)
    print("I will consider the following files:")
    print(" * %s" % outcar)
    print(" * %s" % oszicar)
    print(" * %s\n" % poscar)

    # read data
    freeze = readSelectiveDynamics(poscar)
    nions = len(freeze)
    nfreeze = [el[0] for el in freeze].count(True)
    osz = Oszicar(oszicar)
    nionic_steps = len(osz.ionic_steps)

    if nionic_steps <= 1:
        print("SCF Convergence only")
        print(" * SCF cycles: %d" % len(osz.electronic_steps[0]))

        # electronic convergence only
        energy = [it["E"] for it in osz.electronic_steps[0]]

        font = {'family': 'serif', 'size': 18}
        plt.rc('font', **font)
        plt.figure(figsize=(11.69, 8.27))  # A4
        plt.plot(energy, "o--")
        plt.grid(True)
        plt.title("SCF convergence")
        plt.xlabel("Electronic step")
        plt.ylabel("Energie   /   eV")

    else:
        # ionic convergence
        print(" * N ionic steps: %d" % nionic_steps)
        print(" * N ions       : %d" % nions)
        print(" * N ions frozen: %d" % nfreeze)

        # ionic step energies
        e_fr_energy = [it["F"] for it in osz.ionic_steps]

        # read forces
        with open(outcar, "r") as out:
            fmax = list()
            fave = list()
            fstd = list()
            fcst = list()
            fcstmax = list()
            fcstmin = list()

            line = out.readline()
            while line != "":
                line = out.readline()
                if "EDIFFG" in line:
                    ediffg = float(line.split()[2])
                    print(" * EDIFFG       : %f" % ediffg)

                if "TOTAL-FORCE" in line:
                    out.readline()
                    forces = np.array(
                        [[float(fx) for fx in out.readline().split()[4:7]]
                         for iat in range(nions)])
                    forces = np.sqrt((forces**2).sum(axis=1))
                    valmax = -1
                    ave = 0.
                    av2 = 0.
                    avecst = 0.
                    cstmax = -1
                    cstmin = 1e10

                    for iat in range(nions):
                        if not freeze[iat][0]:
                            valmax = max(valmax, forces[iat])
                            ave += forces[iat]
                            av2 += forces[iat]**2
                        else:
                            avecst += forces[iat]
                            cstmax = max(cstmax, forces[iat])
                            cstmin = min(cstmin, forces[iat])
                    if nions - nfreeze != 0:
                        ave /= float(nions - nfreeze)
                        av2 /= float(nions - nfreeze)
                    else:
                        Colors.cprint("y", "WARNINGS, all ions seems to be frozen")
                        ave /= float(nions)
                        av2 /= float(nions)
                    av2 = sqrt(av2 - ave**2)

                    if nfreeze != 0:
                        avecst /= float(nfreeze)
                    else:
                        avecst = 0.

                    fmax.append(valmax)
                    fave.append(ave)
                    fstd.append(av2)
                    fcst.append(avecst)
                    fcstmax.append(cstmax)
                    fcstmin.append(cstmin)

        delta_F = list()
        for i in range(nionic_steps - 1):
            delta_F.append(fabs(e_fr_energy[i + 1] - e_fr_energy[i]))

        font = {'family': 'sans', 'size': 18}
        plt.rc('font', **font)
        fig = plt.figure(figsize=(11.69, 8.27))  # A4
        fig.subplots_adjust(wspace=0.25)
        fig.suptitle("VASP convergence", fontsize=24)

        # graph1 = total energy
        graph1 = fig.add_subplot(2, 2, 1)
        graph1.set_ylabel("Energy   /   eV")
        graph1.set_xlabel("ionic step")
        graph1.grid()
        graph1.plot(e_fr_energy, "r")
        graph1.set_xlim(0, nionic_steps + 1)

        # graph2 = Free energy variation
        graph2 = fig.add_subplot(2, 2, 3, sharex=graph1)
        graph2.set_ylabel("$\Delta F$   /   eV")
        graph2.set_xlabel("ionic step")
        graph2.grid()
        graph2.plot(delta_F, "r")
        if ediffg > 0.:
            graph2.hlines(ediffg, 0, nionic_steps + 1, color="k",
                          linestyle="--")
        graph2.set_xlim(0, nionic_steps + 1)

        # graph3 = forces acting on ions
        graph3 = fig.add_subplot(1, 2, 2, sharex=graph1)
        graph3.set_ylabel("forces   /   eV/$\AA$")
        graph3.set_xlabel("ionic step")
        graph3.grid()
        graph3.plot(fmax, "r", label="max")
        graph3.plot(fave, "g", label="ave")
        graph3.plot(fstd, "c", label="std")
        if nfreeze != 0:
            graph3.plot(fcstmax, "b--", label="max frozen")
            # graph3.plot(fcstmin, "b--")
        graph3.legend(ncol=2, fancybox=True, shadow=True, loc="upper right",
                      prop={"size": 14})
        graph3.set_title("Forces on ions")
        if ediffg < 0.:
            graph3.hlines(-ediffg, 0, nionic_steps + 1, color="k",
                          linestyle="--")
        graph3.set_xlim(0, nionic_steps + 1)

    # plot data
    plt.show()


def get_forces(outfile):
    """ Read and print forces acting on each ion """

    # read number of ions
    freeze = readSelectiveDynamics("POSCAR")
    struct = mg.Structure.from_file("POSCAR")
    nat = len(freeze)

    # read EDIFFG
    if os.path.exists("INCAR"):
        incar = Incar.from_file("INCAR")
        if "EDIFFG" in incar:
            ediffg = incar["EDIFFG"]
        else:
            ediffg = 100.
            Colors.cprint("y", "EDIFFG not in INCAR, set EDIFFG = 100.")
        if ediffg > 0.:
            Colors.cprint("y", "EDIFFG > 0.")
    else:
        _die("\nError, I need an INCAR file", 1)

    # read last forces on OUTCAR
    with open(outfile, "r") as out:
        line = out.readline()
        while line != "":
            line = out.readline()

            if "TOTAL-FORCE" in line:
                forces = list()
                out.readline()
                for iat in range(nat):
                    line = out.readline()
                    fxyz = np.array([float(fx) for fx in line.split()[3:6]])
                    f = np.sqrt((fxyz**2).sum())
                    forces.append(fxyz.tolist() + [f])

    # output
    print(72 * "-")
    print("                      TOTAL FORCES ON ATOMS ")
    print(72 * "-")
    print(" iat at   freeze     fx        fy        fz          f            cvg")
    print(72 * "-")
    for iat in range(nat):
        m = ("%4d %3s  " + 3 * "%2s" + 3 * "%10.4f" + " %10.3f") % \
            tuple([iat + 1, struct[iat].specie.symbol] + freeze[iat][1:] + forces[iat])
        if freeze[iat][0]:
            Colors.cprint("b", m + "  frozen")
        else:
            if ediffg < 0:
                if forces[iat][-1] < -ediffg:
                    Colors.cprint("g", m + "        cvg")
                else:
                    Colors.cprint("r", m)
            else:
                print(m)
    print(72 * "-")

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# compute things
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


def chgsum():
    """ linear add of CHGCAR files """

    scale_factor = 1.

    # command line options
    if len(sys.argv) == 4:
        chgcar1 = sys.argv[2]
        chgcar2 = sys.argv[3]

    elif len(sys.argv) == 5:
        chgcar1 = sys.argv[2]
        chgcar2 = sys.argv[3]
        try:
            scale_factor = float(sys.argv[4])
        except ValueError:
            _die("Error, scale_factor must be a number", 1)
    else:
        _die("Error in arguemnts list. try {0} -h to get some \
            help".format(sys.argv[0]), 1)

    # ask if you agree the computation
    print("I will compute : {0} + {1}*{2}".format(chgcar1, scale_factor,
                                                  chgcar2))

    if not question("Do you agree ?"):
        _die()

    # files exist ?
    if not os.path.exists(chgcar1):
        _die("Error : File '{0}' does not exist !\n".format(chgcar1))

    if not os.path.exists(chgcar2):
        _die("Error : File '{0}' does not exist !\n".format(chgcar2))

    # sum densities
    print("Reading {0}".format(chgcar1))
    rho1 = Chgcar.from_file(chgcar1)
    print("Reading {0}".format(chgcar2))
    rho2 = Chgcar.from_file(chgcar2)
    rho_sum = rho1.linear_add(rho2, scale_factor)

    # name of output file
    print(dashedLine)
    if os.path.exists("CHGCAR_sum"):
        if not question("file CHGCAR_sum exists, overwrite it ?"):
            _die()
    print(" write sum density in : CHGCAR_sum\n" + dashedLine)
    rho_sum.write_file("CHGCAR_sum")


def get_deplacement(xmlfile="vasprun.xml", fs1=None, fs2=None):
    """ get displacement between two structures """

    if xmlfile:
        if not os.path.exists(xmlfile):
            _die("ERROR, file %s does not exist" % xmlfile, 1)

        try:
            run = Vasprun(xmlfile)
            struct1 = run.initial_structure
            struct2 = run.final_structure
        except:
            fs1 = "POSCAR"
            fs2 = "CONTCAR"
            Colors.cprint("y", "\n# BAD RUN TERMINATION #, I try to read POSCAR and CONTCAR\n")
            xmlfile = None

    if fs1 and fs2:
        if not os.path.exists(fs1):
            _die("ERROR, file %s does not exist" % fs1, 1)
        if not os.path.exists(fs2):
            _die("ERROR, file %s does not exist" % fs2, 1)
        struct1 = mg.Structure.from_file(fs1)
        struct2 = mg.Structure.from_file(fs2)

        if len(struct1.sites) != len(struct2.sites):
            _die("ERROR, structures are unconsistant", 1)

    print("Structure 1 : " + struct1.composition.reduced_formula)
    print("abc      : %10.4f %10.4f %10.4f" % struct1.lattice.abc)
    print("angles   : %10.4f %10.4f %10.4f" % struct1.lattice.angles)

    print("\nStructure 2 : " + struct2.composition.reduced_formula)
    print("abc      : %10.4f %10.4f %10.4f" % struct2.lattice.abc)
    print("angles   : %10.4f %10.4f %10.4f" % struct2.lattice.angles)

    # compute atoms displacement
    print("\n" + 75 * "-")
    print("   atome    positions initiales          positions finales       distance")
    print(75 * "-")
    iat = 0
    for site1, site2 in zip(struct1, struct2):
        iat += 1
        ligne = "%4d%4s" % (iat, site1.specie.symbol)
        for x in site1.coords:
            ligne += "%8.3f" % x

        ligne += "    "
        for x in site2.coords:
            ligne += "%8.3f" % x

        ligne += "    "
        d, j = site1.distance_and_image(site2)
        ligne += "%8.3f" % d
        if (j != np.zeros(3)).all():
            ligne += "(%2d,%2d,%2d)" % tuple(j)

        print(ligne)


def make_supercell(nx=1, ny=1, nz=1):
    """
    Read a structure from CONTCAR or POSCAR file and build a supercell
    whith the dimension nx*a x ny*b x nz.

    Arguments:
        nx (int): number of duplicate along a
        ny (int): number of duplicate along b
        nz (int): number of duplicate along c

    Return:
        Print structure into a POSCAR file
    """

    # file to read
    if os.path.exists("CONTCAR"):
        filename = "CONTCAR"
    elif os.path.exists("POSCAR"):
        filename = "POSCAR"
    else:
        filename = input("Structure file name: ")

    # build supercell
    print("read file : " + filename)
    s = mg.Structure.from_file(filename)
    s.make_supercell([nx, ny, nz])
    p = Poscar(s)
    outfile = "POSCAR_%dx%dx%d.vasp" % (nx, ny, nz)
    print("write file: " + outfile)
    p.write_file(outfile)

    return s


def neighbors(iat, radius=3.0, struct="POSCAR"):
    """
    Print the neighbor list of atom number iat.
    """

    print("read file ----> %s\n" % struct)

    s = mg.Structure.from_file(struct)
    nlist = s.get_neighbors(s[iat], radius)  # .sort(key = lambda x: x[1])

    # sort by neighbor distance
    nlist.sort(key=lambda x: x[1])

    print("Neighbors of atom %s_%d" % (s[iat].specie.symbol, iat + 1))
    for n in nlist:
        site, d = n
        print("    %3s: %8.3f" % (site.specie.symbol, d))


def all_neighbors(radius=3., struct="POSCAR"):
    """
    Print neighbors of all atoms in the cell.
    """

    # threshold for same neighbors
    th = 0.001

    # get all neighbors
    s = mg.Structure.from_file(struct)
    allneig = s.get_all_neighbors(radius)

    iat = 0
    for site, neiglist in zip(s, allneig):
        iat += 1
        print("\nNeighbors of atom %s_%d" % (site.specie.symbol, iat))
        neiglist.sort(key=lambda x: x[1])
        uneq = list()
        for neig in neiglist:
            site, d = neig
            if len(uneq) == 0:
                uneq.append((site, d, 1))
            else:
                new = True
                for i, u in enumerate(uneq):
                    usite, ud, n = u
                    if usite.specie.symbol == site.specie.symbol and \
                            fabs(d - ud) < th:
                        new = False
                        n += 1
                        uneq[i] = (usite, ud, n)
                        break
                if new:
                    uneq.append((site, d, 1))

        for neig in uneq:
            site, d, n = neig
            print("    %3s (%2d): %10.4f" % (site.specie.symbol, n, d))

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# various tools
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


class Colors(object):
    """ a tool in order to print with color """
    BLACK = '\033[30m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    VIOLET = '\033[95m'
    CYAN = '\033[96m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

    avail = {"v": VIOLET, "b": BLUE, "g": GREEN, "c": CYAN, "y": YELLOW,
             "warning": WARNING, "r": RED, "fail": FAIL, "k": BLACK, "w": ENDC}

    @classmethod
    def cprint(cls, color, m):
        """ print m in color """
        if color in cls.avail:
            print(cls.avail[color] + m + cls.ENDC)
        else:
            print(cls.WARNING + "%s not available \t" % color + cls.ENDC + m)

    @classmethod
    def show(cls, m="toto"):
        """ display all available colors """
        for color in cls.avail:
            cls.cprint(color, "%-8s : %s" % (color, m))


class HumanSize(object):
    """ convert octet size in human format """

    KILO_OCTET = 1024
    MEGA_OCTET = 1048576
    GIGA_OCTET = 1073741824
    TERA_OCTET = 1099511627776

    @classmethod
    def compute(cls, taille):
        """ return a byte number in human readable format (1ko 234Mo 2Go)

        >>> HumanSize.compute(345)
        '345 o'
        >>> HumanSize.compute(123478)
        '120.6 ko'
        >>> HumanSize.compute(983435743)
        '937.9 Mo'
        >>> HumanSize.compute(12983435743)
        '12.1 Go'
        >>> HumanSize.compute(755812983435743)
        '687.4 To'

        """
        taille = float(taille)
        if taille >= cls.TERA_OCTET:
            size = "%.1f To" % (taille / cls.TERA_OCTET)
        elif taille >= cls.GIGA_OCTET:
            size = "%.1f Go" % (taille / cls.GIGA_OCTET)
        elif taille >= cls.MEGA_OCTET:
            size = "%.1f Mo" % (taille / cls.MEGA_OCTET)
        elif taille >= cls.KILO_OCTET:
            size = "%.1f ko" % (taille / cls.KILO_OCTET)
        else:
            size = "%.0f o" % taille

        return size


if __name__ == "__main__":
    check()
    select()
